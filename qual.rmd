---
title: "Quantity has a quality all of its own"
author: "Luke Hayden"
date: "October 22nd, 2018"
output: html_document
---



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
library(dplyr)
library(ggbiplot)
library(tibble)
library(tidyr)
library(reshape2)
library(matrixStats)
library(gtools)
library(GGally)
library(philentropy)
library(ggrepel)
```

#Intro

The quality of the Nanostring samples varies considerably, depending on the quantity of RNA present, extraction quality, Ncounter factors, hybridization success, etc. The Nanostring method includes some internal controls that allow us to exclude some samples, but this is a fairly crude and not very stringent method. More samples than flagged need to be removed. 
Up to now, I have been using a somewhat ad-hoc approach, removing samples either on the basis of numbers of genes expressed (biased where we are also looking at the expression of the same genes) or simply removing outliers. Now it's time to devise a better approach. As Michalis suggested, I will be using the "housekeeping" genes whcih are used to normalise the samples. 

##Ways of determining quality

-Via expression levels of housekeeping genes

-Via relative levels of housekeeping genes
Should expect consistent ratios


```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#setwd("~/Documents/nstringjul18")
load(file="allns_data.rdata")
load(file="sampleinfo.rdata")
````



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


mc <- melt(ctall.norm/rowMeans(ctall.norm, na.rm=T))
colnames(mc) <- c("marker", "sample", "expression")
mc <- left_join(mc, sampleinfo, by= "sample") %>%
#  left_join(posdf, by= "sample") %>%
  mutate(ctgsamp= paste0(ctg,"  ",  sample, ": ", over10reads  ))



# (p=ggplot(mc, aes(x=marker, y=expression, colour=over0reads)) +geom_point() +
#   facet_wrap(~ctgsamp, ncol=6)+
#     scale_y_log10()+
#     scale_colour_gradient(high="green", low="red2")+
#     theme_minimal()
#   )
#   
# ggsave(plot=p, filename = "qual.pdf", device="pdf", height=40, width=6, limitsize = F)
#   

````

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
hkdat <- as.data.frame(t(ctall.hk))

nhkdat <- t(ctall.hk/rowMeans(ctall.hk))

meds <- colMedians(t(ctall.hk))


hkdat$over1 <- rowSums(hkdat>0)
hkdat$over3 <- rowSums(t(ctall.hk)>3)

hkdat$over5 <- rowSums(t(ctall.hk)>5)


hkdat$over10 <- rowSums(t(ctall.hk)>10)

hkdat$sample <- rownames(hkdat)

````



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
save(hkdat, file="hkdat.rdata")

````

#Expression levels and replicability

Need to establish an appropriate threshold of expression above which replicability is acceptable. Look at the samples for which two Nanostring replicates are available. 

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


md <- as.data.frame(t(subset(t(ctall.unnorm), 
                 sampleinfo$prep == "Nikos" & 
                 sampleinfo$ctg %in% 3:4&
  !(sampleinfo$sample %in% c("O1a", "O1b", "YR1a", "YR1b" , "YR2a", "YR2b")))))


si <- subset(sampleinfo, sampleinfo$sample %in% colnames(md))


sl <- as.character(sampleinfo$sample[sampleinfo$sample %in% colnames(md)])

md$marker <- rownames(md)

mmd <- gather(as.data.frame(md), key="sample", value="expression", sl) 
mmd$gp <- substr(mmd$sample, 1, nchar(mmd$sample)-1)

mmd$rep <- substr(mmd$sample,  nchar(mmd$sample), nchar(mmd$sample))


md <- select(mmd, -sample) 


mmd2 <- left_join( select(dplyr::rename(filter(md, rep=="a"), expression_a =expression), -rep),
                   select(dplyr::rename(filter(md, rep=="b"), expression_b =expression), -rep),
                   by=c("marker", "gp") )


ggplot(mmd2, aes(x=expression_a, y=expression_b))+
  geom_point(alpha=0.1, colour="red2")+
  geom_smooth(method="lm")+
# geom_hex()+
  theme_bw()+
   scale_x_log10()+
  scale_y_log10()+
  xlab("Expression Replicate B")+
  ylab("Expression Replicate A")+
 ggtitle("How much expression needed for replicability? ", subtitle = "All genes, samples with replicates")

````

And looking at the residual variation:

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}

ablm <- lm(expression_a~expression_b, data=mmd2)
#summary(ablm)

mmd2$predexpa <- predict(ablm)
mmd2$resid <- mmd2$expression_a -mmd2$predexpa


mmd2$abfc <- foldchange2logratio(foldchange(mmd2$expression_a, mmd2$expression_b))
mmd2$absabfc <- abs(mmd2$abfc)
mmd2$normresid <- mmd2$resid/mmd2$expression_b
mmd2$absnormresid <- abs(mmd2$normresid)


mmd2$percdiff <-100*(abs(mmd2$expression_a- mmd2$expression_b))/mmd2$expression_b



ggplot(mmd2, aes(y=percdiff, x=expression_b))+
  geom_point(alpha=0.1, colour="red2")+
  stat_smooth()+
  geom_vline(xintercept=5, linetype=2)+
 
  geom_vline(xintercept=3, linetype=2)+ 
  geom_vline(xintercept=10, linetype=2)+
# geom_hex()+
  theme_bw()+
  scale_x_log10()+
  xlab("Expression Replicate B")+
  ylab("% Difference between replicates")+
 ggtitle("How much expression needed for replicability? ", subtitle = "All genes, samples with replicates")
```

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}

md <- as.data.frame(t(subset(t(ctall.hk), 
                 sampleinfo$prep == "Nikos" & 
                 sampleinfo$ctg %in% 3:4&
  !(sampleinfo$sample %in% c("O1a", "O1b", "YR1a", "YR1b" , "YR2a", "YR2b")))))


si <- subset(sampleinfo, sampleinfo$sample %in% colnames(md))


sl <- as.character(sampleinfo$sample[sampleinfo$sample %in% colnames(md)])

md$marker <- rownames(md)

mmd <- gather(as.data.frame(md), key="sample", value="expression", sl) 
mmd$gp <- substr(mmd$sample, 1, nchar(mmd$sample)-1)

mmd$rep <- substr(mmd$sample,  nchar(mmd$sample), nchar(mmd$sample))


md <- select(mmd, -sample) 


mmd2 <- left_join( select(dplyr::rename(filter(md, rep=="a"), expression_a =expression), -rep),
                   select(dplyr::rename(filter(md, rep=="b"), expression_b =expression), -rep),
                   by=c("marker", "gp") )
mmd2$ma <- substr(mmd2$marker, 1,2)

ggplot(mmd2, aes(x=expression_a, y=expression_b, label=ma ))+
  geom_point(aes(colour=ma))+
  geom_smooth(method="lm")+
 geom_text(aes(colour=ma))+
  theme_bw()+
   scale_x_log10()+
  scale_y_log10()+
  xlab("Expression Replicate B")+
  ylab("Expression Replicate A")+
 ggtitle("How much expression needed for replicability? ",  subtitle = "Housekeeping genes, samples with replicates")
````
 

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
  
ablm <- lm(expression_a~expression_b, data=mmd2)
#summary(ablm)

mmd2$predexpa <- predict(ablm)
mmd2$resid <- mmd2$expression_a -mmd2$predexpa


mmd2$abfc <- foldchange2logratio(foldchange(mmd2$expression_a, mmd2$expression_b))
mmd2$absabfc <- abs(mmd2$abfc)
mmd2$normresid <- mmd2$resid/mmd2$expression_b
mmd2$absnormresid <- abs(mmd2$normresid)


mmd2$percdiff <-100*(abs(mmd2$expression_a- mmd2$expression_b))/mmd2$expression_b


ggplot(mmd2, aes(y=percdiff, x=expression_b,   label=ma ))+
  geom_point(aes(colour=ma))+
  stat_smooth()+
  geom_vline(xintercept=5, linetype=2)+
  
  geom_vline(xintercept=3, linetype=2)+
  
  geom_vline(xintercept=10, linetype=2)+
# geom_hex()+
  theme_bw()+
  scale_x_log10()+
  xlab("Expression Replicate B")+
  ylab("%diff replicate A")+
 ggtitle("How much expression needed for replicability? ", subtitle = "Housekeeping genes, samples with replicates")
```


Anywhere above 5-10 reads starts to look somewhat reasonable here. 

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
#View(hkdat)

mhkd <- gather(hkdat, key="threshold", value="numhk", over1, over3,over5,over10)
  
mhkd$threshold <- factor(mhkd$threshold, levels= c("over1", "over3","over5","over10"))




ggplot(mhkd, aes(x=numhk))+
  facet_wrap(~threshold, ncol=1)+
  geom_bar(fill="red3")+
  theme_bw()+
  xlab("number of Housekeeping genes above threshold")+
  ylab("Samples")
# 
# 
# 
# ggplot(d2, aes(x = factor(groupchange), y = perc, fill = factor(Symscore3))) +
#   geom_bar(stat="identity", width = 0.7) +
#   scale_y_continuous(breaks = brks, labels = scales::percent(brks))

```




```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


md <- as.data.frame(t(subset(t(ctall.unnorm), 
                 sampleinfo$prep == "Nikos" & 
                 sampleinfo$ctg %in% 3:4&
  !(sampleinfo$sample %in% c("O1a", "O1b", "YR1a", "YR1b" , "YR2a", "YR2b")))))


si <- subset(sampleinfo, sampleinfo$sample %in% colnames(md))


sl <- as.character(sampleinfo$sample[sampleinfo$sample %in% colnames(md)])

md$marker <- rownames(md)

mmd <- gather(as.data.frame(md), key="sample", value="expression", sl) 
mmd$gp <- substr(mmd$sample, 1, nchar(mmd$sample)-1)

mmd$rep <- substr(mmd$sample,  nchar(mmd$sample), nchar(mmd$sample))


md <- select(mmd, -sample) 


mmd2 <- left_join( select(dplyr::rename(filter(md, rep=="a"), expression_a =expression), -rep),
                   select(dplyr::rename(filter(md, rep=="b"), expression_b =expression), -rep),
                   by=c("marker", "gp") )


mmd2$percdiff <-100*(abs(mmd2$expression_a- mmd2$expression_b))/mmd2$expression_b
mmd2 <- subset(mmd2, mmd2$expression_a >0 & mmd2$expression_b >0)

polypercdiff <- lm(percdiff~poly(expression_b,4), data=mmd2)

modpercdiff <- lm(percdiff~expression_b, data=mmd2)
modpercdiff <- loess(percdiff~expression_b, data=mmd2)
mmd2$predpdiff <- predict(modpercdiff)

ggplot(mmd2, aes(y=percdiff, x=expression_b))+
  geom_point(alpha=0.1, colour="red2")+
  geom_line(aes(y=predpdiff), colour="forest green", size=2)+
  geom_vline(xintercept=5, linetype=2)+
 
  geom_vline(xintercept=3, linetype=2)+ 
  geom_vline(xintercept=10, linetype=2)+
# geom_hex()+
  theme_bw()+
  scale_x_log10()+
  xlab("Expression Replicate B")+
  ylab("% Difference between replicates")+
 ggtitle("How much expression needed for replicability? ", subtitle = "All genes, samples with replicates")


````



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.height=20}




mhk <- hkdat[, 1:5]

mhk[mhk < 0.1] <- 1 #LOESS needs values of at least 1
mhk[mhk > 1000] <-1000

mhk$HLpred = predict(modpercdiff, newdata= mhk[,1])
mhk$EOpred = predict(modpercdiff, newdata= mhk[,2])
mhk$EQpred = predict(modpercdiff, newdata= mhk[,3])
mhk$AQpred = predict(modpercdiff, newdata= mhk[,4])
mhk$BSpred = predict(modpercdiff, newdata= mhk[,5])       

mhk$meanpred <- rowMeans(mhk[,6:10])

mhk$sample <- rownames(mhk)



mhk$sample <- factor(mhk$sample, levels=mhk$sample[order(mhk$meanpred)])
mhk$flag <- mhk$sample %in% sampleinfo$sample[sampleinfo$flag ==T]

ggplot(mhk, aes(y=meanpred,x=sample, fill=flag))+
  geom_bar(stat="identity")+
coord_flip()+
  theme_bw()+
 ylab("Predicted replicability (from mean of 5 housekeeping genes)")+
scale_fill_brewer(palette="Set1")+
  ggtitle("Sample trustworthiness")
```


#Housekeeping gene expression

To place this into context, we need to ask how strongly expressed our housekeeping genes are. 

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


mhk <- hkdat[, 1:5]

hkexp <- melt(mhk[,1:5])

ggplot(hkexp, aes(x=value, fill=variable))+
  geom_density(alpha=0.6)+
  theme_bw()+
  geom_vline(xintercept=5, linetype=2)+
  
  geom_vline(xintercept=3, linetype=2)+
  
  geom_vline(xintercept=10, linetype=2)+
  scale_fill_brewer(palette = "Set1", name="Housekeeping \nGene")+
  facet_wrap(~variable)+
  scale_x_log10()+
  xlab("Expression (raw counts)")+
  ggtitle("Expression ranges of Housekeeping genes")

````

From previous



#Housekeeping Gene intercorrelation




```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
reorder_cormat <- function(cormat){
# Use correlation between variables as distance
dd <- as.dist((1-cormat)/2)
hc <- hclust(dd)
cormat <-cormat[hc$order, hc$order]
}

 get_lower_tri<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
  }
  # Get upper triangle of the correlation matrix
  get_upper_tri <- function(cormat){
    cormat[lower.tri(cormat)]<- NA
    return(cormat)
  }
  

mhk <- hkdat[, 1:5]


mhk <- mhk[ , order(names(mhk))]
cormat <- round(cor(mhk),2)  
  
cormat <- reorder_cormat(cormat)
upper_tri <- get_upper_tri(cormat)

mcm <- melt(cormat, na.rm = TRUE)



ggplot(data = mcm, aes(Var1, Var2, fill = value, label=value))+
 geom_tile(color = "white")+
    geom_text(colour="black")+
 scale_fill_gradient2(low = "red3", high = "cornflower blue", mid = "white", 
   midpoint = 0.5, limit = c(0,1), space = "Lab", 
   name="Pearson\nCorrelation") +
  theme_minimal()+ 
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 12, hjust = 1))+
 coord_fixed()+
  xlab("")+
  ylab("")+
  ggtitle("Correlation between Housekeeping Genes")

````




```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
ggpairs(mhk)+
  theme_bw()+
  ggtitle("Correlation and pairwise plotting between Housekeeping Genes")

````

##PCA of Housekeeping genes


```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


log <-     sampleinfo$flag == FALSE

# 
# 
# log <-  
#   sampleinfo$flag == FALSE
#log <- TRUE

bcmin <- as.matrix(ctall.hk[,log==T])
bcmin.groups <- sampleinfo$flag[log==T]
tbc <- as.matrix(t(bcmin))
bc.pca <- prcomp(tbc,center = TRUE,scale. = TRUE) 
bc.groups <- bcmin.groups


ggbiplot(bc.pca, obs.scale = 1, var.scale = 1, ellipse = FALSE, circle = TRUE, var.axes=T, labels=rownames(tbc), groups = bc.groups)+
  ggtitle("PCA based on housekeeping gene expression")+
    theme_minimal() +
  scale_colour_manual(values=c("cornflower blue", "red3", "black"), guide=F)

```

Two extreme outlier samples. Not that these samples  What if we remove them? 


```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


log <-   !(sampleinfo$sample %in% c("AG", "AI")) &
  sampleinfo$flag == FALSE

# 
# 
# log <-  
#   sampleinfo$flag == FALSE
#log <- TRUE

bcmin <- as.matrix(ctall.hk[,log==T])
bcmin.groups <- sampleinfo$flag[log==T]
tbc <- as.matrix(t(bcmin))
bc.pca <- prcomp(tbc,center = TRUE,scale. = TRUE) 
bc.groups <- bcmin.groups


ggbiplot(bc.pca, obs.scale = 1, var.scale = 1, ellipse = FALSE, circle = TRUE, var.axes=T, labels=rownames(tbc), groups = bc.groups)+
  ggtitle("PCA based on housekeeping gene expression", 
          subtitle="2 outliers excluded")+
    theme_minimal() +
  scale_colour_manual(values=c("cornflower blue", "red3", "black"), guide=F)


```

PCA changes drastically! Any housekeeping gene ratio method will need to remove these at least (these are strongly expressed and so won't be cut out by other methods). 

#Housekeeping genes to predict one another

If low quality samples don't follow the same correlations between housekeeping gene expression, we can look to exclude those which don't fit the pattern

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


log <-   !(sampleinfo$sample %in% c("AG", "AI", "AB")) &
  sampleinfo$flag == FALSE
#log <- TRUE

mhk <- as.data.frame(t(ctall.hk[,log==T])) 

colnames(mhk) <- substr(colnames(mhk),1,2)


lmhl <- lm(HL~., data=mhk)
lmeo <- lm(EO~., data=mhk)
lmfq <- lm(FQ~., data=mhk)
lmaq <- lm(AQ~., data=mhk)
lmbs <- lm(BS~., data=mhk)

mhk <-   rownames_to_column(mhk, var="sample")
allhk <- as.data.frame(t(ctall.hk)) 

colnames(allhk) <- substr(colnames(allhk),1,2)

allhk <- rownames_to_column(allhk, var="sample")

predf <- data.frame("HL"= predict(lmhl, newdata = allhk), 
                    "EO"= predict(lmeo, newdata = allhk),
                    "FQ"= predict(lmfq, newdata = allhk),
                    "AQ"= predict(lmaq, newdata = allhk),
                    "BS"= predict(lmbs, newdata = allhk), 
                    "sample"= allhk$sample) 

mpredf <- gather(predf, key= "hk", value="predexp", -sample)
mmhk <- gather(mhk, key="hk", value="exp", -sample) %>%
  left_join(mpredf, by=c("hk", "sample"))


mallhk <- gather(allhk, key="hk", value="exp", -sample) %>%
  left_join(mpredf, by=c("hk", "sample"))

hkm <- data.frame(mean= colMeans(t(ctall.hk[,log==T])), hk=substr(colnames(t(ctall.hk[,log==T])),1,2))


mmhk$resid <- mmhk$exp-mmhk$predexp

mallhk$resid <- mallhk$exp-mmhk$predexp
mallhk$flag <- mallhk$sample %in% sampleinfo$sample[  sampleinfo$flag == T]
mallhk <- left_join(mallhk, hkm, by= "hk")
mallhk$normresid <- mallhk$resid/mallhk$mean

p=ggplot(mmhk, aes(x=exp, y=predexp))+geom_point()+
  facet_wrap(~hk)+
  scale_y_log10()+
  scale_x_log10()+
  theme_bw()+
  ylab("Predicted expression")+
  xlab("Expression")


````



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
p=ggplot(mallhk, aes(x=normresid, fill=flag))+
  geom_density(alpha=0.5)+
  theme_bw()+
scale_fill_brewer(palette="Set1")+
  facet_wrap(~hk)+
  xlim(-30, 30)

````



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}
  
mallhk$sample <- as.factor(mallhk$sample)
  
smallhk <- mallhk %>% 
  group_by(sample) %>%
  dplyr::summarise(meannormresid=mean(abs(normresid))) %>%
  left_join(select(filter(mallhk, hk=="HL"), sample, flag), by="sample")




p=ggplot(smallhk, aes(x=meannormresid, fill=flag))+
  geom_density(alpha=0.5)+
  theme_bw()+
scale_fill_brewer(palette="Set1")

  
````



#Observed vs expected proportional expression of Housekeeping genes

Use chi-square tests to compare the proportial expression of 


```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}

log <-    sampleinfo$flag == FALSE


mhk <- as.data.frame(t(ctall.hk[,log==T])) 

expected <- colSums(mhk)/sum(colSums(mhk))

mhkall <-  as.data.frame(t(ctall.hk)) 

mhkall <- subset(mhkall, rowSums(mhkall) !=0)

eo <- cbind(mhkall, t(data.frame(expected)))

   # expected proportions


chi.result <- apply(eo, 1, function (x) chisq.test(x=x[1:5],p=x[6:10]))
mhkall$p_value <- unlist(lapply(chi.result, function(x) x$p.value))

mhkall$chistat <- unlist(lapply(chi.result, function(x) x$statistic))

mhkall$flag <- rownames(mhkall) %in% sampleinfo$sample[sampleinfo$flag==T]
mhkall$sample <- rownames(mhkall)

ggplot(mhkall, aes(x=chistat,fill=flag))+
  geom_density(alpha=0.5)+
  theme_bw()+
scale_fill_brewer(palette="Set1", name="Sample flagged?")+
  xlab("Chi-stat (proportional expression of housekeeping genes)")+
  ggtitle("Deviation from observed/expected")
 # scale_x_continuous(trans="log2")





````



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}

ggplot(mhkall, aes(x=chistat,y=p_value,colour=flag, label=sample))+
  geom_point()+
#  geom_text_repel()+
  theme_bw()+
scale_colour_brewer(palette="Set1", name="Sample flagged?")+
  xlab("Chi-stat (proportional expression of housekeeping genes)")+
  scale_x_log10()+
  ggtitle("Deviation from observed/expected")

````

Results are very significant, but we don't want to be so stringent as to remove all samples with a statistically sound deviation from average ratios, we just need to remove the 

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.height = 20}
mhkall$sample <- factor(mhkall$sample, levels=mhkall$sample[order(mhkall$chistat)])


(p=ggplot(mhkall, aes(y=chistat,x=sample, fill=flag))+
  geom_bar(stat="identity")+
coord_flip()+
  theme_bw()+
  ylab("Chi-square stat (deviation from expected housekeeping ratio)")+
scale_fill_brewer(palette="Set1"))+
  ggtitle("Ranking deviation from observed/expected")#+  theme(axis.text.y = element_text(angle = 0, hjust =0, size=3)))
#  scale_x_log10()

chimhkall <-mhkall
#ggsave(plot=p, filename = "chi.pdf", height=13, width=4)

````


Here, we can simply add a cut-off on the basis of this Chi-statistic. Note that our previous "weird outliers" are thrown out by this measure. 

#Jensen-Shannon Divergence 

Compute the difference between two probability distributions. 

```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE, fig.height = 20}

log <-    sampleinfo$flag == FALSE


mhk <- as.data.frame(t(ctall.hk[,log==T])) 

expected <- colSums(mhk)/sum(colSums(mhk))

mhkall <-  as.data.frame(t(ctall.hk))
mhkall <- mhkall/rowSums(mhkall)

mhkall <- subset(mhkall, rowSums(mhkall) !=0)

jsd.result <- list()

for (i in 1:nrow(mhkall)){
  q <- as.numeric(mhkall[i,])
  p <- expected
  
  x <- rbind(p,q)
  jsd.result[i] <- JSD(x)
  
}

mhkall$jsdres <- unlist(jsd.result)
mhkall$sample <- rownames(mhkall)
mhkall <- left_join( select(mhkall, sample, jsdres), chimhkall, by="sample")

mhkall$sample <- factor(mhkall$sample, levels=mhkall$sample[order(mhkall$jsdres)])
(p=ggplot(mhkall, aes(y=jsdres,x=sample, fill=flag))+
  geom_bar(stat="identity")+
coord_flip()+
  theme_bw()+
  ylab("Jensen-Shannon Divergence")+
scale_fill_brewer(palette="Set1"))+
  ggtitle("Ranking deviation from observed/expected (JSD)")
````

The top few of these are also fairly poor samples that don't fit expected patterns



```{r, echo=FALSE, warning=FALSE, error=FALSE, message=FALSE}


ggplot(mhkall, aes(x=chistat,y=jsdres,colour=flag, label=sample))+
  geom_point()+
 geom_label()+
  theme_bw()+
scale_colour_brewer(palette="Set1", name="Sample flagged?")+
  xlab("Chi-stat (proportional expression of housekeeping genes)")+
  ylab("Jensen-Shannon Divergence")+
  scale_x_log10()+
  scale_y_log10()+
  ggtitle("Deviation from observed/expected: JSD vs Chi-square")
````


#Proposals

I propose the removal of samples that: 




